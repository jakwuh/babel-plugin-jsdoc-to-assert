{"version":3,"sources":["../src/index.js"],"names":["t","types","template","injectParameterAssert","path","leadingComments","state","bindings","node","params","forEach","param","name","loc","identifierName","comments","map","comment","value","items","unwrap","length","asserts","location","bodyPath","get","item","tag","binding","scope","hasBinding","Error","push","validation","options","opts","ast","join","unshiftContainer","visitor","enter","parentNode","parentPath","parentParentNode","isExportNamedDeclaration","isExportDefaultDeclaration","isObjectProperty","isVariableDeclarator","isVariableDeclaration","isAssignmentExpression","isExpressionStatement","isObjectMethod","isClassMethod","isFunctionDeclaration","containsTypeComment","test"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport {parseComment} from 'jsdoc-to-condition'\nimport {getLocation, isProcessed, markProcessed, validate} from './util';\nimport {generateAssert} from './generators';\nimport {flatten} from 'lodash';\nimport {BabelPath, Types} from './babel-types';\n\ntype PluginOptions = {\n    mode?: string,\n    logger?: string\n}\n\n// `comment` node contains @type, return true\nfunction containsTypeComment(comment: void | { value: string }): boolean {\n    return comment ? false : /@type/.test(comment.value);\n}\n\nexport default function ({types: t, template}: { types: Types }) {\n\n    // function injectTypeAssert(declarationsPath, identifierName, leadingComments, state) {\n    //     let Generator = getGenerator(options.generator, state);\n    //\n    //     let\n    // asserts = leadingComments.reduce((asserts, comment) => {\n    //         return asserts.concat(CommentConverter.toTypeAsserts(identifierName, comment, {Generator}));\n    //     }, []);\n    //\n    //     if (asserts.length) {\n    //         let functionDeclarationString = trimSpaceEachLine(asserts).join('\\n');\n    //         let builtAssert = template(functionDeclarationString)();\n    //         if (builtAssert) {\n    //             declarationsPath.insertAfter(builtAssert);\n    //         }\n    //     }\n    // }\n\n    function injectParameterAssert(path: BabelPath, leadingComments, state) {\n        if (isProcessed(path) || !validate(leadingComments, state)) {\n            return;\n        }\n\n        markProcessed(path);\n\n        let bindings = {};\n\n        path.node.params.forEach(param => {\n            if (param.name !== param.loc.identifierName) {\n                bindings[param.loc.identifierName] = param.name;\n            }\n        });\n\n        let comments = leadingComments.map(comment => `/*${comment.value}*/`),\n            items = flatten(comments.map(comment => parseComment(comment, {unwrap: true, bindings})));\n\n        if (!items.length || !path.node.loc) {\n            return;\n        }\n\n        let asserts = [],\n            location = getLocation(path, state),\n            bodyPath = path.get('body');\n\n        items.forEach(item => {\n            let {name, binding} = item.tag;\n\n            if (name in bindings) {\n                binding = bindings[name];\n            } else if (bodyPath.scope.hasBinding(binding)) {\n                binding = name;\n            } else {\n                throw new Error(`${location}: Parameter ${binding} described in JSDoc doesn't exist`);\n            }\n\n            bindings[name] = binding;\n\n            asserts.push(generateAssert({\n                name,\n                binding,\n                validation: item.validation,\n                tag: item.tag,\n                options: state.opts,\n                location\n            }));\n        });\n\n        let ast = template(asserts.join('\\n'))();\n        path.get('body').unshiftContainer('body', ast);\n    }\n\n    return {\n        visitor: {\n            ['ObjectMethod|ClassMethod|FunctionDeclaration|FunctionExpression|ArrowFunctionExpression']: {\n                enter(path) {\n                    let leadingComments,\n                        node = path.node,\n                        parentNode = path.parentPath && path.parentPath.node,\n                        parentParentNode = parentNode && path.parentPath.parentPath && path.parentPath.parentPath.node;\n\n                    if (t.isExportNamedDeclaration(parentNode) || t.isExportDefaultDeclaration(parentNode)) {\n                        leadingComments = parentNode.leadingComments;\n                    } else if (t.isObjectProperty(parentNode)) {\n                        leadingComments = parentNode.leadingComments;\n                    } else if (t.isVariableDeclarator(parentNode) && t.isVariableDeclaration(parentParentNode)) {\n                        leadingComments = parentParentNode.leadingComments;\n                    } else if (t.isAssignmentExpression(parentNode) && t.isExpressionStatement(parentParentNode)) {\n                        leadingComments = parentParentNode.leadingComments;\n                    } else if (t.isObjectMethod(node) || t.isClassMethod(node) || t.isFunctionDeclaration(node)) {\n                        leadingComments = node.leadingComments;\n                    }\n\n                    injectParameterAssert(path, leadingComments, this);\n                }\n            }\n        }\n    };\n}\n"]}