{"version":3,"sources":["../src/index.js"],"names":["t","types","template","injectParameterAssert","path","leadingComments","state","comments","map","comment","value","items","unwrap","length","node","loc","asserts","assertedBindings","location","bodyPath","get","forEach","name","item","tag","binding","String","replace","asserted","includes","push","scope","hasBinding","Error","validation","options","opts","ast","join","unshiftContainer","visitor","parentNode","parentPath","parentParentNode","isExportNamedDeclaration","isExportDefaultDeclaration","isObjectProperty","isVariableDeclarator","isVariableDeclaration","isAssignmentExpression","isExpressionStatement","isObjectMethod","isClassMethod","isFunctionDeclaration","containsTypeComment","test"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport {parseComment} from 'jsdoc-to-condition'\nimport {getLocation, isProcessed, markProcessed, validate} from './util';\nimport {generateAssert} from './generators';\nimport {flatten} from 'lodash';\nimport {Types} from './babel-types';\n\ntype PluginOptions = {\n    generator: string\n}\n\n// `comment` node contains @type, return true\nfunction containsTypeComment(comment: void | { value: string }): boolean {\n    return comment ? false : /@type/.test(comment.value);\n}\n\nexport default function ({types: t, template}: { types: Types }) {\n\n    // function injectTypeAssert(declarationsPath, identifierName, leadingComments, state) {\n    //     let Generator = getGenerator(options.generator, state);\n    //\n    //     let\n    // asserts = leadingComments.reduce((asserts, comment) => {\n    //         return asserts.concat(CommentConverter.toTypeAsserts(identifierName, comment, {Generator}));\n    //     }, []);\n    //\n    //     if (asserts.length) {\n    //         let functionDeclarationString = trimSpaceEachLine(asserts).join('\\n');\n    //         let builtAssert = template(functionDeclarationString)();\n    //         if (builtAssert) {\n    //             declarationsPath.insertAfter(builtAssert);\n    //         }\n    //     }\n    // }\n\n    function injectParameterAssert(path, leadingComments, state) {\n        if (isProcessed(path) || !validate(leadingComments, state)) {\n            return;\n        }\n\n        markProcessed(path);\n\n        let comments = leadingComments.map(comment => `/*${comment.value}*/`),\n            items = flatten(comments.map(comment => parseComment(comment, {unwrap: true})));\n\n        if (!items.length || !path.node.loc) {\n            return;\n        }\n\n        let asserts = [],\n            assertedBindings = [],\n            location = getLocation(path, state),\n            bodyPath = path.get('body');\n\n        items.forEach(item => {\n            let {name} = item.tag,\n                binding = String(name).replace(/\\..*$/, ''),\n                asserted = assertedBindings.includes(binding);\n\n            assertedBindings.push(binding);\n\n            if (!asserted && !bodyPath.scope.hasBinding(binding)) {\n                throw new Error(`${location}: Parameter ${binding} described in JSDoc doesn't exist`);\n            } else {\n                asserts.push(generateAssert({\n                    validation: item.validation,\n                    tag: item.tag,\n                    options: state.opts,\n                    location\n                }));\n            }\n        });\n\n        let ast = template(asserts.join('\\n'))();\n        path.get('body').unshiftContainer('body', ast);\n    }\n\n    return {\n        visitor: {\n            ['ObjectMethod|ClassMethod|FunctionDeclaration|FunctionExpression|ArrowFunctionExpression'](path) {\n                let leadingComments,\n                    node = path.node,\n                    parentNode = path.parentPath && path.parentPath.node,\n                    parentParentNode = parentNode && path.parentPath.parentPath && path.parentPath.parentPath.node;\n\n                if (t.isExportNamedDeclaration(parentNode) || t.isExportDefaultDeclaration(parentNode)) {\n                    leadingComments = parentNode.leadingComments;\n                } else if (t.isObjectProperty(parentNode)) {\n                    leadingComments = parentNode.leadingComments;\n                } else if (t.isVariableDeclarator(parentNode) && t.isVariableDeclaration(parentParentNode)) {\n                    leadingComments = parentParentNode.leadingComments;\n                } else if (t.isAssignmentExpression(parentNode) && t.isExpressionStatement(parentParentNode)) {\n                    leadingComments = parentParentNode.leadingComments;\n                } else if (t.isObjectMethod(node) || t.isClassMethod(node) || t.isFunctionDeclaration(node)) {\n                    leadingComments = node.leadingComments;\n                }\n\n                injectParameterAssert(path, leadingComments, this);\n            }\n        }\n    };\n}\n"]}