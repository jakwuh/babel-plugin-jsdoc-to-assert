{"version":3,"sources":["../src/index.js"],"names":["t","types","template","injectParameterAssert","path","leadingComments","state","bindings","node","params","forEach","param","name","loc","identifierName","comments","map","comment","value","items","unwrap","length","asserts","location","bodyPath","get","item","tag","binding","varBinding","split","scope","hasBinding","Error","push","validation","options","opts","ast","join","unshiftContainer","visitor","enter","parentNode","parentPath","parentParentNode","isExportNamedDeclaration","isExportDefaultDeclaration","isObjectProperty","isVariableDeclarator","isVariableDeclaration","isAssignmentExpression","isExpressionStatement","isObjectMethod","isClassMethod","isFunctionDeclaration","containsTypeComment","test"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport {parseComment} from 'jsdoc-to-condition'\nimport {getLocation, isProcessed, markProcessed, validate} from './util';\nimport {generateAssert} from './generators';\nimport {flatten} from 'lodash';\nimport {BabelPath, Types} from './babel-types';\n\ntype PluginOptions = {\n    mode?: string,\n    logger?: string\n}\n\n// `comment` node contains @type, return true\nfunction containsTypeComment(comment: void | { value: string }): boolean {\n    return comment ? false : /@type/.test(comment.value);\n}\n\nexport default function ({types: t, template}: { types: Types }) {\n\n    // function injectTypeAssert(declarationsPath, identifierName, leadingComments, state) {\n    //     let Generator = getGenerator(options.generator, state);\n    //\n    //     let\n    // asserts = leadingComments.reduce((asserts, comment) => {\n    //         return asserts.concat(CommentConverter.toTypeAsserts(identifierName, comment, {Generator}));\n    //     }, []);\n    //\n    //     if (asserts.length) {\n    //         let functionDeclarationString = trimSpaceEachLine(asserts).join('\\n');\n    //         let builtAssert = template(functionDeclarationString)();\n    //         if (builtAssert) {\n    //             declarationsPath.insertAfter(builtAssert);\n    //         }\n    //     }\n    // }\n\n    function injectParameterAssert(path: BabelPath, leadingComments, state) {\n        if (isProcessed(path) || !validate(leadingComments, state)) {\n            return;\n        }\n\n        markProcessed(path);\n\n        let bindings = {};\n\n        path.node.params.forEach(param => {\n            if (param.name !== param.loc.identifierName) {\n                bindings[param.loc.identifierName] = param.name;\n            }\n        });\n\n        let comments = leadingComments.map(comment => `/*${comment.value}*/`),\n            items = flatten(comments.map(comment => parseComment(comment, {unwrap: true, bindings})));\n\n        if (!items.length || !path.node.loc) {\n            return;\n        }\n\n        let asserts = [],\n            location = getLocation(path, state),\n            bodyPath = path.get('body');\n\n        items.forEach(item => {\n            let {name, binding} = item.tag,\n                varBinding = binding.split('.')[0];\n\n           if (!bodyPath.scope.hasBinding(varBinding)) {\n                throw new Error(`${location}: Parameter ${binding} described in JSDoc doesn't exist`);\n            }\n\n            asserts.push(generateAssert({\n                name,\n                binding,\n                validation: item.validation,\n                tag: item.tag,\n                options: state.opts,\n                location\n            }));\n        });\n\n        let ast = template(asserts.join('\\n'))();\n        path.get('body').unshiftContainer('body', ast);\n    }\n\n    return {\n        visitor: {\n            ['ObjectMethod|ClassMethod|FunctionDeclaration|FunctionExpression|ArrowFunctionExpression']: {\n                enter(path) {\n                    let leadingComments,\n                        node = path.node,\n                        parentNode = path.parentPath && path.parentPath.node,\n                        parentParentNode = parentNode && path.parentPath.parentPath && path.parentPath.parentPath.node;\n\n                    if (t.isExportNamedDeclaration(parentNode) || t.isExportDefaultDeclaration(parentNode)) {\n                        leadingComments = parentNode.leadingComments;\n                    } else if (t.isObjectProperty(parentNode)) {\n                        leadingComments = parentNode.leadingComments;\n                    } else if (t.isVariableDeclarator(parentNode) && t.isVariableDeclaration(parentParentNode)) {\n                        leadingComments = parentParentNode.leadingComments;\n                    } else if (t.isAssignmentExpression(parentNode) && t.isExpressionStatement(parentParentNode)) {\n                        leadingComments = parentParentNode.leadingComments;\n                    } else if (t.isObjectMethod(node) || t.isClassMethod(node) || t.isFunctionDeclaration(node)) {\n                        leadingComments = node.leadingComments;\n                    }\n\n                    injectParameterAssert(path, leadingComments, this);\n                }\n            }\n        }\n    };\n}\n"]}