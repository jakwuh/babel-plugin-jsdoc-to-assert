{"version":3,"sources":["../src/index.js"],"names":["t","types","template","injectParameterAssert","path","leadingComments","state","comments","map","comment","value","items","unwrap","length","node","loc","asserts","assertedBindings","location","bodyPath","get","forEach","name","item","tag","binding","String","replace","asserted","includes","push","hasBinding","scope","params","Error","validation","options","opts","ast","join","unshiftContainer","visitor","enter","parentNode","parentPath","parentParentNode","isExportNamedDeclaration","isExportDefaultDeclaration","isObjectProperty","isVariableDeclarator","isVariableDeclaration","isAssignmentExpression","isExpressionStatement","isObjectMethod","isClassMethod","isFunctionDeclaration","containsTypeComment","test","find","param","identifierName"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport {parseComment} from 'jsdoc-to-condition'\nimport {getLocation, isProcessed, markProcessed, validate} from './util';\nimport {generateAssert} from './generators';\nimport {flatten} from 'lodash';\nimport {Types} from './babel-types';\n\ntype PluginOptions = {\n    mode?: string,\n    logger?: string\n}\n\n// `comment` node contains @type, return true\nfunction containsTypeComment(comment: void | { value: string }): boolean {\n    return comment ? false : /@type/.test(comment.value);\n}\n\n\nfunction hasBinding(scope, params = [], name) {\n    return scope.hasBinding(name) || params.find(param => param.loc.identifierName === name);\n}\n\nexport default function ({types: t, template}: { types: Types }) {\n\n    // function injectTypeAssert(declarationsPath, identifierName, leadingComments, state) {\n    //     let Generator = getGenerator(options.generator, state);\n    //\n    //     let\n    // asserts = leadingComments.reduce((asserts, comment) => {\n    //         return asserts.concat(CommentConverter.toTypeAsserts(identifierName, comment, {Generator}));\n    //     }, []);\n    //\n    //     if (asserts.length) {\n    //         let functionDeclarationString = trimSpaceEachLine(asserts).join('\\n');\n    //         let builtAssert = template(functionDeclarationString)();\n    //         if (builtAssert) {\n    //             declarationsPath.insertAfter(builtAssert);\n    //         }\n    //     }\n    // }\n\n    function injectParameterAssert(path, leadingComments, state) {\n        if (isProcessed(path) || !validate(leadingComments, state)) {\n            return;\n        }\n\n        markProcessed(path);\n\n        let comments = leadingComments.map(comment => `/*${comment.value}*/`),\n            items = flatten(comments.map(comment => parseComment(comment, {unwrap: true})));\n\n        if (!items.length || !path.node.loc) {\n            return;\n        }\n\n        let asserts = [],\n            assertedBindings = [],\n            location = getLocation(path, state),\n            bodyPath = path.get('body');\n\n        items.forEach(item => {\n            let {name} = item.tag,\n                binding = String(name).replace(/\\..*$/, ''),\n                asserted = assertedBindings.includes(binding);\n\n            assertedBindings.push(binding);\n\n            if (!asserted && !hasBinding(bodyPath.scope, path.node.params, binding)) {\n                throw new Error(`${location}: Parameter ${binding} described in JSDoc doesn't exist`);\n            } else {\n                asserts.push(generateAssert({\n                    validation: item.validation,\n                    tag: item.tag,\n                    options: state.opts,\n                    location\n                }));\n            }\n        });\n\n        let ast = template(asserts.join('\\n'))();\n        path.get('body').unshiftContainer('body', ast);\n    }\n\n    return {\n        visitor: {\n            ['ObjectMethod|ClassMethod|FunctionDeclaration|FunctionExpression|ArrowFunctionExpression']: {\n                enter(path) {\n                    let leadingComments,\n                        node = path.node,\n                        parentNode = path.parentPath && path.parentPath.node,\n                        parentParentNode = parentNode && path.parentPath.parentPath && path.parentPath.parentPath.node;\n\n                    if (t.isExportNamedDeclaration(parentNode) || t.isExportDefaultDeclaration(parentNode)) {\n                        leadingComments = parentNode.leadingComments;\n                    } else if (t.isObjectProperty(parentNode)) {\n                        leadingComments = parentNode.leadingComments;\n                    } else if (t.isVariableDeclarator(parentNode) && t.isVariableDeclaration(parentParentNode)) {\n                        leadingComments = parentParentNode.leadingComments;\n                    } else if (t.isAssignmentExpression(parentNode) && t.isExpressionStatement(parentParentNode)) {\n                        leadingComments = parentParentNode.leadingComments;\n                    } else if (t.isObjectMethod(node) || t.isClassMethod(node) || t.isFunctionDeclaration(node)) {\n                        leadingComments = node.leadingComments;\n                    }\n\n                    injectParameterAssert(path, leadingComments, this);\n                }\n            }\n        }\n    };\n}\n"]}